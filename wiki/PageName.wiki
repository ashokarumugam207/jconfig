#labels Featured
An introduction to jConfig

= Introduction =

A first simple example on how to use jConfig


= Details =

Nothing better than a simple example to see how things works.

We want to introduce in our application a configuration file to manage information about a distribuited cache system (ie memcache).
Let's create our configuration file.

For the cache system I want something self explanatory like the following xml fragment:
{{{
<configuration id="cache" plugin="com.google.code.jconfig.reader.plugins.CacheConfigurationPlugin">
	<servers>
		<server name="server 1" port="1000"/>
		<server name="server 2" port="1010"/>
		<server name="server 3" port="1020"/>
	</servers>
</configuration>
}}}

The fixed part for every configuration is only the configuration tag with its two attributes.
The first attribute represents a unique id for that particular configuration while the second attribute represents a fully qualified name of the custom class that will parse that particular xml fragment and will return a custom configuration object
 containing the data exposed in the configuration.

An example of a full configuration file:
{{{
<configurations>
	<configuration id="general" plugin="com.google.code.jconfig.reader.plugins.PropertyConfigurationPlugin">
		<property key="key-1" value="value 1" />
		<property key="key-2" value="value 2" />
		<property key="key-3" value="value 3" />
		<property key="key-4" value="value 4" />
	</configuration>
		
	<configuration id="cache" plugin="com.google.code.jconfig.reader.plugins.CacheConfigurationPlugin">
		<servers>
			<server name="server 1" port="1000"/>
			<server name="server 2" port="1010"/>
			<server name="server 3" port="1020"/>
		</servers>
	</configuration>
</configurations>
}}}

As you can see it's up to you to decide what are the best xml structure to represent your data.
The library provides a PropertyConfigurationPlugin that works like a map, adding/removing/updating items will drive to a configuration changes.

Now it's time to define our custom bean that will contain the data and the plugin that will read that exact xml fragment.
Our bean model is very simple:
{{{
public class ServerBean {
	private String host;
	private Integer port;
	
	public ServerBean(String host, Integer port) {
		this.host = host;
		this.port = port;
	}

	public String getHost() {
		return host;
	}

	public Integer getPort() {
		return port;
	}
}
}}}

And our plugin:
{{{
public class CacheConfigurationPlugin implements IConfigurationPlugin<List<ServerBean>> {

	public List<ServerBean> readConfiguration(IHierarchicalReader reader) {
		
		IHierarchicalReader serversNode = reader.getChildren().get(0);
		List<ServerBean> servers = new ArrayList<ServerBean>();
		for (IHierarchicalReader child : serversNode.getChildren()) {
			servers.add(new ServerBean(child.getAttributeValue("name"), Integer.parseInt(child.getAttributeValue("port"))));
		}
		
		return servers;
	}
}
}}}

As you can see I've decided that the object that will contain the configuration data will be a java.util.List but, thanks to the generics, you can customize it as you want.
The plugin receive a hierarchical reader that will contain only that peace of code of our cache configuration. The hierarchical reader acts like a tree.

So now we have created our xml, our custom bean containing the data and the plugin that will parse the xml and will create our bean.
We need one more thing, a configuration change listener so we will be notified upon configuration changes.

In this example I'll keep the things simple by printing out the values of the server.
{{{
private class CacheConfigurationChangeListener implements IConfigurationChangeListener {

		public <T> void loadConfiguration(T configuration) {
			List<ServerBean> conf = (List<ServerBean>)configuration;
			for (ServerBean server : conf) {
				System.out.println(server);
			}
		}
	}
}
}}}

That's all. Now all you have to do is to register the listener:
{{{
String configPath = "absolute config path";
Map<String, IConfigurationChangeListener> listeners = new HashMap<String, IConfigurationChangeListener>();
listeners.put("cache", new CacheConfigurationChangeListener());
ConfigurationManager.configureAndWatch(listeners, configPath, 200L);
}}}

It's up to you how combine listener and the config data.
For example you could create a configuration container that implements IConfigurationChangeListener and hold the configuration data.
{{{
public class CacheConfigurationContainer implements IConfigurationChangeListener {
	private List<ServerBean> cacheServers = new ArrayList<ServerBean>();
		
	// useful method used to retrieve the data - I'll keep it simple
	public List<ServerBean> getCacheServerList() {
		return cacheServers;
	}
		
	public <T> void loadConfiguration(T configuration) {
		cacheServers.clear();
		List<ServerBean> conf = (List<ServerBean>)configuration;
		for (ServerBean server : conf) {
			cacheServers.add(server);
		}
	}
}

String configPath = "absolute config path";
Map<String, IConfigurationChangeListener> listeners = new HashMap<String, IConfigurationChangeListener>();
listeners.put("cache", new CacheConfigurationContainer());
ConfigurationManager.configureAndWatch(listeners, configPath, 200L);
}}}

In this case you 'll have to prevent that while a thread is trying to access the getCacheServerList method, a configuration reloading will be taken at the same time.